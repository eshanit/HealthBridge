<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Relations\BelongsTo;
use Illuminate\Database\Eloquent\Relations\BelongsToMany;

/**
 * StoredReport Model
 * 
 * Represents clinical reports synced from CouchDB.
 * These reports are generated by the AI system and include:
 * - Discharge summaries
 * - Clinical handovers (SBAR format)
 * - Referral reports
 * - Comprehensive reports
 * 
 * @property int $id
 * @property string $report_uuid
 * @property string $couch_id
 * @property string $report_type
 * @property string|null $session_couch_id
 * @property string|null $patient_cpt
 * @property string|null $filename
 * @property string $mime_type
 * @property int $size_bytes
 * @property string|null $pdf_base64
 * @property string|null $pdf_path
 * @property string|null $html_content
 * @property \Carbon\Carbon|null $generated_at
 * @property int|null $generated_by_user_id
 * @property string|null $generated_by_name
 * @property bool $synced
 * @property \Carbon\Carbon|null $synced_at
 * @property \Carbon\Carbon|null $couch_updated_at
 * @property array|null $raw_document
 * @property \Carbon\Carbon|null $created_at
 * @property \Carbon\Carbon|null $updated_at
 */
class StoredReport extends Model
{
    use HasFactory;

    /**
     * Report type constants
     */
    public const TYPE_DISCHARGE = 'discharge';
    public const TYPE_HANDOVER = 'handover';
    public const TYPE_REFERRAL = 'referral';
    public const TYPE_COMPREHENSIVE = 'comprehensive';

    /**
     * The attributes that are mass assignable.
     *
     * @var array<int, string>
     */
    protected $fillable = [
        'report_uuid',
        'couch_id',
        'report_type',
        'session_couch_id',
        'patient_cpt',
        'filename',
        'mime_type',
        'size_bytes',
        'pdf_base64',
        'pdf_path',
        'html_content',
        'generated_at',
        'generated_by_user_id',
        'generated_by_name',
        'synced',
        'synced_at',
        'couch_updated_at',
        'raw_document',
    ];

    /**
     * The attributes that should be cast.
     *
     * @var array<string, string>
     */
    protected $casts = [
        'report_uuid' => 'string',
        'synced' => 'boolean',
        'generated_at' => 'datetime',
        'synced_at' => 'datetime',
        'couch_updated_at' => 'datetime',
        'raw_document' => 'array',
        'size_bytes' => 'integer',
    ];

    /**
     * Get the user who generated this report.
     */
    public function generatedBy(): BelongsTo
    {
        return $this->belongsTo(User::class, 'generated_by_user_id');
    }

    /**
     * Get the clinical session this report belongs to.
     */
    public function session(): BelongsTo
    {
        return $this->belongsTo(ClinicalSession::class, 'session_couch_id', 'couch_id');
    }

    /**
     * Get the patient this report is for.
     */
    public function patient(): BelongsTo
    {
        return $this->belongsTo(Patient::class, 'patient_cpt', 'cpt');
    }

    /**
     * Scope to filter by report type.
     */
    public function scopeOfType($query, string $type)
    {
        return $query->where('report_type', $type);
    }

    /**
     * Scope to filter by session.
     */
    public function scopeForSession($query, string $sessionCouchId)
    {
        return $query->where('session_couch_id', $sessionCouchId);
    }

    /**
     * Scope to filter by patient.
     */
    public function scopeForPatient($query, string $patientCpt)
    {
        return $query->where('patient_cpt', $patientCpt);
    }

    /**
     * Scope to get only synced reports.
     */
    public function scopeSynced($query)
    {
        return $query->where('synced', true);
    }

    /**
     * Scope to get only unsynced reports.
     */
    public function scopeUnsynced($query)
    {
        return $query->where('synced', false);
    }

    /**
     * Scope to get recent reports.
     */
    public function scopeRecent($query, int $days = 30)
    {
        return $query->where('generated_at', '>=', now()->subDays($days));
    }

    /**
     * Get the PDF content.
     * 
     * @return string|null Base64 encoded PDF content
     */
    public function getPdfContent(): ?string
    {
        if ($this->pdf_base64) {
            return $this->pdf_base64;
        }

        // If PDF is stored on filesystem, read it
        if ($this->pdf_path && file_exists(storage_path('app/' . $this->pdf_path))) {
            $content = file_get_contents(storage_path('app/' . $this->pdf_path));
            return base64_encode($content);
        }

        return null;
    }

    /**
     * Get the PDF as binary content.
     * 
     * @return string|null Binary PDF content
     */
    public function getPdfBinary(): ?string
    {
        $base64 = $this->getPdfContent();
        
        if ($base64) {
            return base64_decode($base64);
        }

        return null;
    }

    /**
     * Get the file size in human-readable format.
     */
    public function getFormattedSize(): string
    {
        $bytes = $this->size_bytes;
        
        if ($bytes >= 1073741824) {
            return number_format($bytes / 1073741824, 2) . ' GB';
        } elseif ($bytes >= 1048576) {
            return number_format($bytes / 1048576, 2) . ' MB';
        } elseif ($bytes >= 1024) {
            return number_format($bytes / 1024, 2) . ' KB';
        } elseif ($bytes > 1) {
            return $bytes . ' bytes';
        } elseif ($bytes == 1) {
            return '1 byte';
        }
        
        return '0 bytes';
    }

    /**
     * Check if this report has PDF content.
     */
    public function hasPdf(): bool
    {
        return !empty($this->pdf_base64) || (!empty($this->pdf_path) && file_exists(storage_path('app/' . $this->pdf_path)));
    }

    /**
     * Check if this report has HTML content.
     */
    public function hasHtml(): bool
    {
        return !empty($this->html_content);
    }

    /**
     * Get a display name for the report type.
     */
    public function getTypeDisplayName(): string
    {
        return match ($this->report_type) {
            self::TYPE_DISCHARGE => 'Discharge Summary',
            self::TYPE_HANDOVER => 'Clinical Handover',
            self::TYPE_REFERRAL => 'Referral Report',
            self::TYPE_COMPREHENSIVE => 'Comprehensive Report',
            default => ucfirst($this->report_type),
        };
    }

    /**
     * Get statistics about stored reports.
     */
    public static function getStats(): array
    {
        $reports = self::all();
        
        $stats = [
            'total' => $reports->count(),
            'by_type' => [
                self::TYPE_DISCHARGE => 0,
                self::TYPE_HANDOVER => 0,
                self::TYPE_REFERRAL => 0,
                self::TYPE_COMPREHENSIVE => 0,
            ],
            'total_size_bytes' => 0,
            'synced' => 0,
            'unsynced' => 0,
        ];
        
        foreach ($reports as $report) {
            if (isset($stats['by_type'][$report->report_type])) {
                $stats['by_type'][$report->report_type]++;
            }
            
            $stats['total_size_bytes'] += $report->size_bytes;
            
            if ($report->synced) {
                $stats['synced']++;
            } else {
                $stats['unsynced']++;
            }
        }
        
        $stats['total_size_formatted'] = self::formatBytes($stats['total_size_bytes']);
        
        return $stats;
    }

    /**
     * Format bytes to human-readable string.
     */
    protected static function formatBytes(int $bytes): string
    {
        if ($bytes >= 1073741824) {
            return number_format($bytes / 1073741824, 2) . ' GB';
        } elseif ($bytes >= 1048576) {
            return number_format($bytes / 1048576, 2) . ' MB';
        } elseif ($bytes >= 1024) {
            return number_format($bytes / 1024, 2) . ' KB';
        }
        
        return $bytes . ' bytes';
    }
}
